{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* istanbul ignore file */\nconst ethers_1 = require(\"ethers\");\nconst lighthouse_config_1 = require(\"../../../lighthouse.config\");\nconst getTickerPrice = async symbol => {\n  try {\n    const response = await fetch(`${lighthouse_config_1.lighthouseConfig.lighthouseAPI}/api/lighthouse/get_ticker?symbol=${symbol}`);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return data;\n  } catch (error) {\n    throw new Error(`Failed to get ticker price: ${error.message}`);\n  }\n};\nconst calculatePrice = async (size, network, token) => {\n  const minFileSizeInBytes = 1048576; // 1MB\n  const chargeableSizeInMB = Math.max(size, minFileSizeInBytes) / 1048576;\n  const dollarPricePerMB = 0.00390625;\n  const cost = dollarPricePerMB * chargeableSizeInMB;\n  if (token === 'usdc' || token === 'usdt' || token === 'dai') {\n    const decimals = lighthouse_config_1.lighthouseConfig[network][`${token}_contract_decimal`];\n    const priceTODecimals = cost.toFixed(decimals);\n    const priceInSmallestUnits = ethers_1.ethers.parseUnits(priceTODecimals.toString(), decimals);\n    return priceInSmallestUnits;\n  }\n  const tokenPriceInUSD = await getTickerPrice(lighthouse_config_1.lighthouseConfig[network]['symbol']);\n  const priceInToken = cost / tokenPriceInUSD;\n  const priceToDecimals = priceInToken.toFixed(lighthouse_config_1.lighthouseConfig[network].native_decimal);\n  const priceInSmallestUnits = ethers_1.ethers.parseUnits(priceToDecimals.toString(), lighthouse_config_1.lighthouseConfig[network].native_decimal);\n  return priceInSmallestUnits;\n};\nexports.default = async (pathOrSize, network, token) => {\n  try {\n    if (!network) {\n      throw new Error('Token not provided!!!');\n    }\n    if (typeof pathOrSize === 'number') {\n      const price = calculatePrice(pathOrSize, network.toLowerCase(), token?.toLowerCase());\n      return price;\n    } else {\n      let totalSize = 0;\n      for (let i = 0; i < pathOrSize.length; i++) {\n        totalSize = totalSize + pathOrSize[i]['size'];\n      }\n      const price = calculatePrice(totalSize, network.toLowerCase(), token?.toLowerCase());\n      return price;\n    }\n  } catch (error) {\n    throw new Error(error.message);\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","ethers_1","require","lighthouse_config_1","getTickerPrice","symbol","response","fetch","lighthouseConfig","lighthouseAPI","ok","Error","status","data","json","error","message","calculatePrice","size","network","token","minFileSizeInBytes","chargeableSizeInMB","Math","max","dollarPricePerMB","cost","decimals","priceTODecimals","toFixed","priceInSmallestUnits","ethers","parseUnits","toString","tokenPriceInUSD","priceInToken","priceToDecimals","native_decimal","default","pathOrSize","price","toLowerCase","totalSize","i","length"],"sources":["D:/demo/node_modules/@lighthouse-web3/sdk/dist/Lighthouse/payPerDeal/getPrice/web.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* istanbul ignore file */\nconst ethers_1 = require(\"ethers\");\nconst lighthouse_config_1 = require(\"../../../lighthouse.config\");\nconst getTickerPrice = async (symbol) => {\n    try {\n        const response = await fetch(`${lighthouse_config_1.lighthouseConfig.lighthouseAPI}/api/lighthouse/get_ticker?symbol=${symbol}`);\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = (await response.json());\n        return data;\n    }\n    catch (error) {\n        throw new Error(`Failed to get ticker price: ${error.message}`);\n    }\n};\nconst calculatePrice = async (size, network, token) => {\n    const minFileSizeInBytes = 1048576; // 1MB\n    const chargeableSizeInMB = Math.max(size, minFileSizeInBytes) / 1048576;\n    const dollarPricePerMB = 0.00390625;\n    const cost = dollarPricePerMB * chargeableSizeInMB;\n    if (token === 'usdc' || token === 'usdt' || token === 'dai') {\n        const decimals = lighthouse_config_1.lighthouseConfig[network][`${token}_contract_decimal`];\n        const priceTODecimals = cost.toFixed(decimals);\n        const priceInSmallestUnits = ethers_1.ethers.parseUnits(priceTODecimals.toString(), decimals);\n        return priceInSmallestUnits;\n    }\n    const tokenPriceInUSD = await getTickerPrice(lighthouse_config_1.lighthouseConfig[network]['symbol']);\n    const priceInToken = cost / tokenPriceInUSD;\n    const priceToDecimals = priceInToken.toFixed(lighthouse_config_1.lighthouseConfig[network].native_decimal);\n    const priceInSmallestUnits = ethers_1.ethers.parseUnits(priceToDecimals.toString(), lighthouse_config_1.lighthouseConfig[network].native_decimal);\n    return priceInSmallestUnits;\n};\nexports.default = async (pathOrSize, network, token) => {\n    try {\n        if (!network) {\n            throw new Error('Token not provided!!!');\n        }\n        if (typeof pathOrSize === 'number') {\n            const price = calculatePrice(pathOrSize, network.toLowerCase(), token?.toLowerCase());\n            return price;\n        }\n        else {\n            let totalSize = 0;\n            for (let i = 0; i < pathOrSize.length; i++) {\n                totalSize = totalSize + pathOrSize[i]['size'];\n            }\n            const price = calculatePrice(totalSize, network.toLowerCase(), token?.toLowerCase());\n            return price;\n        }\n    }\n    catch (error) {\n        throw new Error(error.message);\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}