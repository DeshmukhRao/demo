{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fetchWithTimeout = exports.checkDuplicateFileNames = exports.addressValidator = exports.isPrivateKey = exports.isCID = void 0;\nconst ethers_1 = require(\"ethers\");\nconst isCID = cid => {\n  return /^(Qm[1-9A-HJ-NP-Za-km-z]{44}|b[A-Za-z2-7]{58}|B[A-Z2-7]{58}|z[1-9A-HJ-NP-Za-km-z]{48}|F[0-9A-F]{50})*$/.test(cid);\n};\nexports.isCID = isCID;\nconst isPrivateKey = key => {\n  return /^([0-9a-f]{64})$/i.test(key);\n};\nexports.isPrivateKey = isPrivateKey;\nconst addressValidator = value => {\n  if (ethers_1.ethers.isAddress(value?.toLowerCase())) {\n    return value.toLowerCase();\n  } else if (/^[A-HJ-NP-Za-km-z1-9]*$/.test(value) && value.length == 44) {\n    return value;\n  }\n  return '';\n};\nexports.addressValidator = addressValidator;\nfunction checkDuplicateFileNames(files) {\n  const fileNames = new Set();\n  for (let i = 0; i < files.length; i++) {\n    const fileName = files[i].name;\n    if (fileNames.has(fileName)) {\n      throw new Error(`Duplicate file name found: ${fileName}`);\n    }\n    fileNames.add(fileName);\n  }\n}\nexports.checkDuplicateFileNames = checkDuplicateFileNames;\nasync function fetchWithTimeout(endpointURL, options) {\n  const {\n    timeout = 8000,\n    onProgress,\n    ...rest\n  } = options;\n  const controller = new AbortController();\n  const id = setTimeout(() => controller.abort(), timeout);\n  try {\n    if (onProgress && rest.body instanceof FormData) {\n      return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open(rest.method || 'GET', endpointURL);\n        if (rest.headers) {\n          if (rest.headers instanceof Headers) {\n            rest.headers.forEach((value, key) => {\n              xhr.setRequestHeader(key, value);\n            });\n          } else if (typeof rest.headers === 'object') {\n            for (const [key, value] of Object.entries(rest.headers)) {\n              xhr.setRequestHeader(key, value);\n            }\n          }\n        }\n        xhr.timeout = timeout;\n        xhr.onload = () => {\n          const headers = new Headers();\n          xhr.getAllResponseHeaders().trim().split(/[\\r\\n]+/).forEach(line => {\n            const parts = line.split(': ');\n            const header = parts.shift();\n            const value = parts.join(': ');\n            if (header) headers.set(header, value);\n          });\n          resolve(new Response(xhr.response, {\n            status: xhr.status,\n            statusText: xhr.statusText,\n            headers: headers\n          }));\n        };\n        xhr.onerror = () => reject(new Error('Network error'));\n        xhr.ontimeout = () => reject(new Error('Request timed out'));\n        xhr.upload.onprogress = event => {\n          if (event.lengthComputable) {\n            onProgress(event.loaded / event.total);\n          }\n        };\n        // Handle different body types\n        if (rest.body instanceof FormData) {\n          xhr.send(rest.body);\n        } else if (rest.body instanceof ReadableStream) {\n          // Convert ReadableStream to Blob and then send\n          new Response(rest.body).blob().then(blob => xhr.send(blob));\n        } else if (typeof rest.body === 'string' || rest.body instanceof Blob || rest.body instanceof ArrayBuffer) {\n          xhr.send(rest.body);\n        } else if (rest.body == null) {\n          xhr.send();\n        } else {\n          reject(new Error('Unsupported body type'));\n        }\n      });\n    } else {\n      const response = await fetch(endpointURL, {\n        ...rest,\n        signal: controller.signal\n      });\n      clearTimeout(id);\n      return response;\n    }\n  } catch (error) {\n    clearTimeout(id);\n    throw error;\n  }\n}\nexports.fetchWithTimeout = fetchWithTimeout;","map":{"version":3,"names":["Object","defineProperty","exports","value","fetchWithTimeout","checkDuplicateFileNames","addressValidator","isPrivateKey","isCID","ethers_1","require","cid","test","key","ethers","isAddress","toLowerCase","length","files","fileNames","Set","i","fileName","name","has","Error","add","endpointURL","options","timeout","onProgress","rest","controller","AbortController","id","setTimeout","abort","body","FormData","Promise","resolve","reject","xhr","XMLHttpRequest","open","method","headers","Headers","forEach","setRequestHeader","entries","onload","getAllResponseHeaders","trim","split","line","parts","header","shift","join","set","Response","response","status","statusText","onerror","ontimeout","upload","onprogress","event","lengthComputable","loaded","total","send","ReadableStream","blob","then","Blob","ArrayBuffer","fetch","signal","clearTimeout","error"],"sources":["D:/demo/node_modules/@lighthouse-web3/sdk/dist/Lighthouse/utils/util.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fetchWithTimeout = exports.checkDuplicateFileNames = exports.addressValidator = exports.isPrivateKey = exports.isCID = void 0;\nconst ethers_1 = require(\"ethers\");\nconst isCID = (cid) => {\n    return /^(Qm[1-9A-HJ-NP-Za-km-z]{44}|b[A-Za-z2-7]{58}|B[A-Z2-7]{58}|z[1-9A-HJ-NP-Za-km-z]{48}|F[0-9A-F]{50})*$/.test(cid);\n};\nexports.isCID = isCID;\nconst isPrivateKey = (key) => {\n    return /^([0-9a-f]{64})$/i.test(key);\n};\nexports.isPrivateKey = isPrivateKey;\nconst addressValidator = (value) => {\n    if (ethers_1.ethers.isAddress(value?.toLowerCase())) {\n        return value.toLowerCase();\n    }\n    else if (/^[A-HJ-NP-Za-km-z1-9]*$/.test(value) && value.length == 44) {\n        return value;\n    }\n    return '';\n};\nexports.addressValidator = addressValidator;\nfunction checkDuplicateFileNames(files) {\n    const fileNames = new Set();\n    for (let i = 0; i < files.length; i++) {\n        const fileName = files[i].name;\n        if (fileNames.has(fileName)) {\n            throw new Error(`Duplicate file name found: ${fileName}`);\n        }\n        fileNames.add(fileName);\n    }\n}\nexports.checkDuplicateFileNames = checkDuplicateFileNames;\nasync function fetchWithTimeout(endpointURL, options) {\n    const { timeout = 8000, onProgress, ...rest } = options;\n    const controller = new AbortController();\n    const id = setTimeout(() => controller.abort(), timeout);\n    try {\n        if (onProgress && rest.body instanceof FormData) {\n            return new Promise((resolve, reject) => {\n                const xhr = new XMLHttpRequest();\n                xhr.open(rest.method || 'GET', endpointURL);\n                if (rest.headers) {\n                    if (rest.headers instanceof Headers) {\n                        rest.headers.forEach((value, key) => {\n                            xhr.setRequestHeader(key, value);\n                        });\n                    }\n                    else if (typeof rest.headers === 'object') {\n                        for (const [key, value] of Object.entries(rest.headers)) {\n                            xhr.setRequestHeader(key, value);\n                        }\n                    }\n                }\n                xhr.timeout = timeout;\n                xhr.onload = () => {\n                    const headers = new Headers();\n                    xhr\n                        .getAllResponseHeaders()\n                        .trim()\n                        .split(/[\\r\\n]+/)\n                        .forEach((line) => {\n                        const parts = line.split(': ');\n                        const header = parts.shift();\n                        const value = parts.join(': ');\n                        if (header)\n                            headers.set(header, value);\n                    });\n                    resolve(new Response(xhr.response, {\n                        status: xhr.status,\n                        statusText: xhr.statusText,\n                        headers: headers,\n                    }));\n                };\n                xhr.onerror = () => reject(new Error('Network error'));\n                xhr.ontimeout = () => reject(new Error('Request timed out'));\n                xhr.upload.onprogress = (event) => {\n                    if (event.lengthComputable) {\n                        onProgress(event.loaded / event.total);\n                    }\n                };\n                // Handle different body types\n                if (rest.body instanceof FormData) {\n                    xhr.send(rest.body);\n                }\n                else if (rest.body instanceof ReadableStream) {\n                    // Convert ReadableStream to Blob and then send\n                    new Response(rest.body).blob().then((blob) => xhr.send(blob));\n                }\n                else if (typeof rest.body === 'string' ||\n                    rest.body instanceof Blob ||\n                    rest.body instanceof ArrayBuffer) {\n                    xhr.send(rest.body);\n                }\n                else if (rest.body == null) {\n                    xhr.send();\n                }\n                else {\n                    reject(new Error('Unsupported body type'));\n                }\n            });\n        }\n        else {\n            const response = await fetch(endpointURL, {\n                ...rest,\n                signal: controller.signal,\n            });\n            clearTimeout(id);\n            return response;\n        }\n    }\n    catch (error) {\n        clearTimeout(id);\n        throw error;\n    }\n}\nexports.fetchWithTimeout = fetchWithTimeout;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}