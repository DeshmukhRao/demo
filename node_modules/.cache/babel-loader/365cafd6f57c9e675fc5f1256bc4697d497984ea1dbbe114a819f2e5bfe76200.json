{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* istanbul ignore file */\nconst kavach_1 = require(\"@lighthouse-web3/kavach\");\nconst encryptionBrowser_1 = require(\"../../encryptionBrowser\");\nconst lighthouse_config_1 = require(\"../../../../lighthouse.config\");\nconst util_1 = require(\"../../../utils/util\");\nconst readFileAsync = file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => {\n      reader.result && resolve(reader.result);\n    };\n    reader.onerror = reject;\n    reader.readAsArrayBuffer(file);\n  });\n};\nexports.default = async (files, apiKey, publicKey, auth_token, uploadProgressCallback) => {\n  try {\n    let keyMap = {};\n    let mimeType = null;\n    if (files.length === 1) {\n      mimeType = files[0].type;\n    }\n    const endpoint = lighthouse_config_1.lighthouseConfig.lighthouseNode + '/api/v0/add?wrap-with-directory=false';\n    const token = 'Bearer ' + apiKey;\n    const fileArr = [];\n    for (let i = 0; i < files.length; i++) {\n      fileArr.push(files[i]);\n    }\n    (0, util_1.checkDuplicateFileNames)(fileArr);\n    if (files.length > 1 && auth_token.startsWith('0x')) {\n      throw new Error(JSON.stringify(`auth_token must be a JWT`));\n    }\n    const formData = new FormData();\n    const filesParam = await Promise.all(fileArr.map(async f => {\n      const {\n        masterKey: fileEncryptionKey,\n        keyShards\n      } = await (0, kavach_1.generate)();\n      const fileData = await readFileAsync(f);\n      const encryptedData = await (0, encryptionBrowser_1.encryptFile)(fileData, fileEncryptionKey);\n      keyMap = {\n        ...keyMap,\n        [f.name]: keyShards\n      };\n      return {\n        data: new Blob([encryptedData], {\n          type: f.type\n        }),\n        fileName: f.name,\n        keyShards\n      };\n    }));\n    filesParam.forEach(function (item_) {\n      return formData.append('file', item_.data, item_.fileName ? item_.fileName : 'file');\n    });\n    const response = uploadProgressCallback ? await (0, util_1.fetchWithTimeout)(endpoint, {\n      method: 'POST',\n      body: formData,\n      timeout: 7200000,\n      headers: {\n        Encryption: `${true}`,\n        Authorization: token\n      },\n      onProgress: progress => {\n        uploadProgressCallback({\n          progress: progress\n        });\n      }\n    }) : await (0, util_1.fetchWithTimeout)(endpoint, {\n      method: 'POST',\n      body: formData,\n      timeout: 7200000,\n      headers: {\n        Encryption: `${true}`,\n        Authorization: token\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    // const reader = response.body?.getReader()\n    // let chunks = []\n    // while (true) {\n    //   const { done, value } = await reader!.read()\n    //   if (done) {\n    //     break\n    //   }\n    //   chunks.push(value)\n    // }\n    // let responseData = new TextDecoder('utf-8').decode(\n    //   new Uint8Array(chunks.flatMap((chunk) => [...chunk]))\n    // ) as any\n    const responseText = await response.text();\n    const jsondata = JSON.parse(responseText);\n    // responseData = JSON.parse(responseData)\n    const savedKey = await Promise.all(jsondata.map(async data => {\n      return (0, kavach_1.saveShards)(publicKey, data.Hash, auth_token, keyMap[data.Name]);\n    }));\n    savedKey.forEach(_savedKey => {\n      if (!_savedKey.isSuccess) {\n        throw new Error(JSON.stringify(_savedKey));\n      }\n    });\n    // return response\n    /*\n      {\n        data: [{\n          Name: 'flow1.png',\n          Hash: 'QmUHDKv3NNL1mrg4NTW4WwJqetzwZbGNitdjr2G6Z5Xe6s',\n          Size: '31735'\n        }]\n      }\n    */\n    return {\n      data: jsondata\n    };\n  } catch (error) {\n    return error.message;\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","kavach_1","require","encryptionBrowser_1","lighthouse_config_1","util_1","readFileAsync","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsArrayBuffer","default","files","apiKey","publicKey","auth_token","uploadProgressCallback","keyMap","mimeType","length","type","endpoint","lighthouseConfig","lighthouseNode","token","fileArr","i","push","checkDuplicateFileNames","startsWith","Error","JSON","stringify","formData","FormData","filesParam","all","map","f","masterKey","fileEncryptionKey","keyShards","generate","fileData","encryptedData","encryptFile","name","data","Blob","fileName","forEach","item_","append","response","fetchWithTimeout","method","body","timeout","headers","Encryption","Authorization","onProgress","progress","ok","status","responseText","text","jsondata","parse","savedKey","saveShards","Hash","Name","_savedKey","isSuccess","error","message"],"sources":["D:/demo/node_modules/@lighthouse-web3/sdk/dist/Lighthouse/uploadEncrypted/encrypt/file/browser.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* istanbul ignore file */\nconst kavach_1 = require(\"@lighthouse-web3/kavach\");\nconst encryptionBrowser_1 = require(\"../../encryptionBrowser\");\nconst lighthouse_config_1 = require(\"../../../../lighthouse.config\");\nconst util_1 = require(\"../../../utils/util\");\nconst readFileAsync = (file) => {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => {\n            reader.result && resolve(reader.result);\n        };\n        reader.onerror = reject;\n        reader.readAsArrayBuffer(file);\n    });\n};\nexports.default = async (files, apiKey, publicKey, auth_token, uploadProgressCallback) => {\n    try {\n        let keyMap = {};\n        let mimeType = null;\n        if (files.length === 1) {\n            mimeType = files[0].type;\n        }\n        const endpoint = lighthouse_config_1.lighthouseConfig.lighthouseNode + '/api/v0/add?wrap-with-directory=false';\n        const token = 'Bearer ' + apiKey;\n        const fileArr = [];\n        for (let i = 0; i < files.length; i++) {\n            fileArr.push(files[i]);\n        }\n        (0, util_1.checkDuplicateFileNames)(fileArr);\n        if (files.length > 1 && auth_token.startsWith('0x')) {\n            throw new Error(JSON.stringify(`auth_token must be a JWT`));\n        }\n        const formData = new FormData();\n        const filesParam = await Promise.all(fileArr.map(async (f) => {\n            const { masterKey: fileEncryptionKey, keyShards } = await (0, kavach_1.generate)();\n            const fileData = await readFileAsync(f);\n            const encryptedData = await (0, encryptionBrowser_1.encryptFile)(fileData, fileEncryptionKey);\n            keyMap = { ...keyMap, [f.name]: keyShards };\n            return {\n                data: new Blob([encryptedData], { type: f.type }),\n                fileName: f.name,\n                keyShards,\n            };\n        }));\n        filesParam.forEach(function (item_) {\n            return formData.append('file', item_.data, item_.fileName ? item_.fileName : 'file');\n        });\n        const response = uploadProgressCallback\n            ? await (0, util_1.fetchWithTimeout)(endpoint, {\n                method: 'POST',\n                body: formData,\n                timeout: 7200000,\n                headers: {\n                    Encryption: `${true}`,\n                    Authorization: token,\n                },\n                onProgress: (progress) => {\n                    uploadProgressCallback({\n                        progress: progress,\n                    });\n                },\n            })\n            : await (0, util_1.fetchWithTimeout)(endpoint, {\n                method: 'POST',\n                body: formData,\n                timeout: 7200000,\n                headers: {\n                    Encryption: `${true}`,\n                    Authorization: token,\n                },\n            });\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        // const reader = response.body?.getReader()\n        // let chunks = []\n        // while (true) {\n        //   const { done, value } = await reader!.read()\n        //   if (done) {\n        //     break\n        //   }\n        //   chunks.push(value)\n        // }\n        // let responseData = new TextDecoder('utf-8').decode(\n        //   new Uint8Array(chunks.flatMap((chunk) => [...chunk]))\n        // ) as any\n        const responseText = await response.text();\n        const jsondata = JSON.parse(responseText);\n        // responseData = JSON.parse(responseData)\n        const savedKey = await Promise.all(jsondata.map(async (data) => {\n            return (0, kavach_1.saveShards)(publicKey, data.Hash, auth_token, keyMap[data.Name]);\n        }));\n        savedKey.forEach((_savedKey) => {\n            if (!_savedKey.isSuccess) {\n                throw new Error(JSON.stringify(_savedKey));\n            }\n        });\n        // return response\n        /*\n          {\n            data: [{\n              Name: 'flow1.png',\n              Hash: 'QmUHDKv3NNL1mrg4NTW4WwJqetzwZbGNitdjr2G6Z5Xe6s',\n              Size: '31735'\n            }]\n          }\n        */\n        return { data: jsondata };\n    }\n    catch (error) {\n        return error.message;\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}