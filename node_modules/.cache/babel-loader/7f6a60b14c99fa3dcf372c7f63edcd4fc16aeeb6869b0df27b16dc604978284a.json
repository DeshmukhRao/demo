{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst lighthouse_config_1 = require(\"../../../../lighthouse.config\");\nconst kavach_1 = require(\"@lighthouse-web3/kavach\");\nconst encryptionNode_1 = require(\"../../encryptionNode\");\nconst node_1 = require(\"../../../upload/files/node\");\nconst util_1 = require(\"../../../utils/util\");\nexports.default = async (sourcePath, apiKey, publicKey, auth_token) => {\n  const fs = eval('require')('fs-extra');\n  const token = 'Bearer ' + apiKey;\n  const endpoint = lighthouse_config_1.lighthouseConfig.lighthouseNode + '/api/v0/add?wrap-with-directory=false';\n  const stats = fs.lstatSync(sourcePath);\n  if (stats.isFile()) {\n    try {\n      const formData = new FormData();\n      const {\n        masterKey: fileEncryptionKey,\n        keyShards\n      } = await (0, kavach_1.generate)();\n      const fileData = fs.readFileSync(sourcePath);\n      const encryptedData = await (0, encryptionNode_1.encryptFile)(fileData, fileEncryptionKey);\n      const blob = new Blob([Buffer.from(encryptedData)]);\n      formData.append('file', blob, sourcePath.replace(/^.*[\\\\/]/, ''));\n      const response = await (0, util_1.fetchWithTimeout)(endpoint, {\n        method: 'POST',\n        body: formData,\n        timeout: 7200000,\n        headers: {\n          Encryption: 'true',\n          Authorization: token\n        }\n      });\n      if (!response.ok) {\n        throw new Error(`Request failed with status code ${response.status}`);\n      }\n      const responseData = await response.json();\n      const {\n        error\n      } = await (0, kavach_1.saveShards)(publicKey, responseData[0].Hash, auth_token, keyShards);\n      if (error) {\n        throw new Error('Error encrypting file');\n      }\n      return {\n        data: responseData\n      };\n    } catch (error) {\n      throw new Error(error.message);\n    }\n  } else {\n    const files = await (0, node_1.walk)(sourcePath);\n    const formData = new FormData();\n    if (files.length > 1 && auth_token.startsWith('0x')) {\n      throw new Error(JSON.stringify(`auth_token must be a JWT`));\n    }\n    let keyMap = {};\n    await Promise.all(files.map(async file => {\n      const {\n        masterKey: fileEncryptionKey,\n        keyShards\n      } = await (0, kavach_1.generate)();\n      const fileData = fs.readFileSync(file);\n      const encryptedData = await (0, encryptionNode_1.encryptFile)(fileData, fileEncryptionKey);\n      const filename = file.slice(sourcePath.length + 1).replaceAll('/', '-');\n      formData.append('file', new Blob([encryptedData]), filename);\n      keyMap = {\n        ...keyMap,\n        [filename]: keyShards\n      };\n      return [filename, keyShards];\n    }));\n    const response = await (0, util_1.fetchWithTimeout)(endpoint, {\n      method: 'POST',\n      body: formData,\n      timeout: 7200000,\n      headers: {\n        Encryption: 'true',\n        Authorization: token\n      }\n    });\n    if (!response.ok) {\n      throw new Error(`Request failed with status code ${response.status}`);\n    }\n    const responseText = await response.text();\n    const jsondata = JSON.parse(responseText);\n    const savedKey = await Promise.all(jsondata.map(async data => {\n      return (0, kavach_1.saveShards)(publicKey, data.Hash, auth_token, keyMap[data.Name]);\n    }));\n    savedKey.forEach(_savedKey => {\n      if (!_savedKey.isSuccess) {\n        throw new Error(JSON.stringify(_savedKey));\n      }\n    });\n    return {\n      data: jsondata\n    };\n  }\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","lighthouse_config_1","require","kavach_1","encryptionNode_1","node_1","util_1","default","sourcePath","apiKey","publicKey","auth_token","fs","eval","token","endpoint","lighthouseConfig","lighthouseNode","stats","lstatSync","isFile","formData","FormData","masterKey","fileEncryptionKey","keyShards","generate","fileData","readFileSync","encryptedData","encryptFile","blob","Blob","Buffer","from","append","replace","response","fetchWithTimeout","method","body","timeout","headers","Encryption","Authorization","ok","Error","status","responseData","json","error","saveShards","Hash","data","message","files","walk","length","startsWith","JSON","stringify","keyMap","Promise","all","map","file","filename","slice","replaceAll","responseText","text","jsondata","parse","savedKey","Name","forEach","_savedKey","isSuccess"],"sources":["D:/demo/node_modules/@lighthouse-web3/sdk/dist/Lighthouse/uploadEncrypted/encrypt/file/node.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst lighthouse_config_1 = require(\"../../../../lighthouse.config\");\nconst kavach_1 = require(\"@lighthouse-web3/kavach\");\nconst encryptionNode_1 = require(\"../../encryptionNode\");\nconst node_1 = require(\"../../../upload/files/node\");\nconst util_1 = require(\"../../../utils/util\");\nexports.default = async (sourcePath, apiKey, publicKey, auth_token) => {\n    const fs = eval('require')('fs-extra');\n    const token = 'Bearer ' + apiKey;\n    const endpoint = lighthouse_config_1.lighthouseConfig.lighthouseNode + '/api/v0/add?wrap-with-directory=false';\n    const stats = fs.lstatSync(sourcePath);\n    if (stats.isFile()) {\n        try {\n            const formData = new FormData();\n            const { masterKey: fileEncryptionKey, keyShards } = await (0, kavach_1.generate)();\n            const fileData = fs.readFileSync(sourcePath);\n            const encryptedData = await (0, encryptionNode_1.encryptFile)(fileData, fileEncryptionKey);\n            const blob = new Blob([Buffer.from(encryptedData)]);\n            formData.append('file', blob, sourcePath.replace(/^.*[\\\\/]/, ''));\n            const response = await (0, util_1.fetchWithTimeout)(endpoint, {\n                method: 'POST',\n                body: formData,\n                timeout: 7200000,\n                headers: {\n                    Encryption: 'true',\n                    Authorization: token,\n                },\n            });\n            if (!response.ok) {\n                throw new Error(`Request failed with status code ${response.status}`);\n            }\n            const responseData = (await response.json());\n            const { error } = await (0, kavach_1.saveShards)(publicKey, responseData[0].Hash, auth_token, keyShards);\n            if (error) {\n                throw new Error('Error encrypting file');\n            }\n            return { data: responseData };\n        }\n        catch (error) {\n            throw new Error(error.message);\n        }\n    }\n    else {\n        const files = await (0, node_1.walk)(sourcePath);\n        const formData = new FormData();\n        if (files.length > 1 && auth_token.startsWith('0x')) {\n            throw new Error(JSON.stringify(`auth_token must be a JWT`));\n        }\n        let keyMap = {};\n        await Promise.all(files.map(async (file) => {\n            const { masterKey: fileEncryptionKey, keyShards } = await (0, kavach_1.generate)();\n            const fileData = fs.readFileSync(file);\n            const encryptedData = await (0, encryptionNode_1.encryptFile)(fileData, fileEncryptionKey);\n            const filename = file.slice(sourcePath.length + 1).replaceAll('/', '-');\n            formData.append('file', new Blob([encryptedData]), filename);\n            keyMap = { ...keyMap, [filename]: keyShards };\n            return [filename, keyShards];\n        }));\n        const response = await (0, util_1.fetchWithTimeout)(endpoint, {\n            method: 'POST',\n            body: formData,\n            timeout: 7200000,\n            headers: {\n                Encryption: 'true',\n                Authorization: token,\n            },\n        });\n        if (!response.ok) {\n            throw new Error(`Request failed with status code ${response.status}`);\n        }\n        const responseText = await response.text();\n        const jsondata = JSON.parse(responseText);\n        const savedKey = await Promise.all(jsondata.map(async (data) => {\n            return (0, kavach_1.saveShards)(publicKey, data.Hash, auth_token, keyMap[data.Name]);\n        }));\n        savedKey.forEach((_savedKey) => {\n            if (!_savedKey.isSuccess) {\n                throw new Error(JSON.stringify(_savedKey));\n            }\n        });\n        return { data: jsondata };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}